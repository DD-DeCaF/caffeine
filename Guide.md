# Guide
This guide intended to describe the conventions and practices to be used in this project. It also starts with a redux guide which still has some open questions[TODO].

### Redux

The reason why redux is being used is that it allows unidirectional data flow. It means that the state is not scattered all around the application in services and components but it lives in a single, immutable object which is the single source of truth at a given moment.

Why is it important? Redux has a steep learning curve especially taking effects into account what uses RXJS observables. Redux is not the only way to cope with state and a nicely designed service-based architecture can work. The problem is there's no clear guide on how a service-based architecture should be designed and the most implicit edge cases usually lead to loops. For this reason for any application that looks a bit more complicated than a TODO list, it is recommended to consider redux which in turn has a very clear guide how to avoid race conditions, how to deal with asynchrony.

Some references: [Facebook video](https://facebook.github.io/flux/), [Redux motivation](https://redux.js.org/introduction/motivation)

## Some rules
- **The state should be denormalized** - no duplications are welcome unless absolutely necessary. (Like an SQL database). In some cases it would be more convenient to store duplicated data - resist the urge with selectors! An example: *Given a list of cards I would like to keep track of the selected card and in a component, I'd like to know if a given card is selected or not. If I keep the selected card id separately, I'd have to write a helper in the component, which tells whether or not the given card is selected. Not very convenient. If I keep a boolean flag on my card, I have to make sure to remove that flag when a new card gets selected. Plus showing the selected card name in a drop-down selector would require filter through the list of cards. Not very convenient either. What I can do is to go with the first data structure (store the selected card Id separately) and create a selector that listens to the list of cards and the selected card Id. Its output would be a list of cards, where there's a boolean flag indicating if the given card is selected or not. In the component, I have the best of both worlds.*
- **Dealing with asynchrony** - We really need asynchrony in modern web apps because that's what allows smooth user experience but redux doesn't have a solution for it out of the box. For react-redux, there are multiple options: redux-thunk, redux-saga, redux-observables. Redux-thunk is really simple, but it quickly outgrows everything except the most simple applications, haven't seen any NgRx implementations. It allows you do dispatch actions from within actions. Redux-saga has its own way of dealing with asynchrony. It is easy to learn, but the NgRx implementation got deprecated in favor of @ngrx/effects. Although redux-thunk is the leading library according to the npm stats, redux-observable is the recommended way by most professionals. It has a steeper learning curve, but it's available for NgRx, and the knowledge gained learning it can be applied in many different scenarios, eg. dealing with user interfaces. This means the following: Components do not trigger API calls directly or via services. There are certain actions that do this in the effects definition file. In these effects when the request is finished (succeeded, or failed) - the actual action gets triggered which updates the state in the reducer. This is how it is currently implemented and it is the recommended way of doing so. However there are a few issues with it, that should be discussed:
  - There's no distinction between actions that should be triggered by components (if we think about the store as a separate module, they would form the interface, because a component should never invoke an internal action) [TODO]
  - "Make an HTTP call, do *this* if succeeds do *that* if fails" is repeated over and over again, which qualifies as code duplication, this logic should be extracted. However this would create additional complexity, so one must be careful with it. [TODO]
  - The InteractiveMap's store has loads of logic, and everything lives in a single file (single action file, single effect file, single reducer file). This should be broken down into smaller pieces. The reducer is normally broken down into smaller pieces with `combineReducers` in react-redux, but it seems undocumented at the moment in NgRx so this should be explored. [TODO]
  - It might be also possible to keep the services as the primary way to deal with asynchrony. This way the component would invoke a method on the service, which would dispatch actions for success and failure, invoke other service methods if required. This was initially discarded because it could lead to circular dependencies, but if there was a circular dependency that'd mean a loop in the async logic as well. It's worth a try to reimplement the initial application bootstrap with services. [TODO]
  - It is also common practice to add a namespace to each action. It means: *There's a LOAD_MODULE action type in InteractiveMap, and there could be another LOAD_MODULE type in the DesignTool. Normally that's perfectly fine since each variable has its own scope. however the state is global, and each action is triggered for each reducer, so if the type string (`const LOAD_MODULE = 'LOAD_MODULE'`) does not contain the module name, it is easy to accidentally update a different module's state. It can be avoided by using `const LOAD_MODULE = '[IM] LOAD_MODULE'`* [TODO]

## Application Architecture
A few points about how the components relate to each other.
- Each module should be self-containing in a sense, that they don't depend on each other. The only allowed dependency is common, lib, and utils.
  - Common will contain all the components that are used in more than one main component. Don't create generic components unless it is required to be generic.
  - Lib contains platform specific code that is not components. Eg if there was a convenience function for adding an effect that takes care of async calls and it depends on NgRx in any way, it can go to lib.
  - Utils will contain pure javascript convenience functions.
- Modules follow a fractal-like structure and common components are stored on each level. Eg: *There's an AppGeneDisplay component in InteractiveMap which is not used multiple times within sub-components of InteractiveMap, but not in other modules, it'd live under InteractiveMap/common*. All components within the main components are also self-containing (except for common modules on a higher level). Lib and utils should be global.
- *Namespacing* The default namespacing says, every component should start with eg. `app-` in order to avoid defining two components with the same name (components are global). This way third parties won't mix with our components. Eg Angular Material uses the `mat-` prefix. This convention to follow is still to be decided. Our modules are likely to grow big, so it could be beneficial to use a main-component based prefix (`im-` for InteractiveMap). [TODO]
- As for the redux store, the similar fractal-like structure should be followed. Only store something in the global state if it's application wide (clipboard/sharing from another module). It would be great to store the selected species globally for the InteractiveMap and the design tool so that sharing could be done flawlessly while persisting state in the InteractiveMap. But other components can be more generic (warehouse). This concern is not really a technical one though, it questions the general product logic / UX. [TODO]